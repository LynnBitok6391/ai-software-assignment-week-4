# Theoretical Analysis – AI in Software Engineering

### Q1: How AI-driven code generation (e.g., GitHub Copilot) reduces development time

AI tools like Copilot suggest code snippets and logic in real time. They reduce repetitive typing, provide quick boilerplate templates, and help developers focus on logic instead of syntax. This accelerates prototyping and debugging.  
However, they can produce incorrect or insecure code, rely heavily on context, and may reflect training data bias. Therefore, human review and testing remain essential.

### Q2: Supervised vs Unsupervised Learning in Bug Detection

Supervised learning uses labeled data (bug vs. no bug) to train models like decision trees or SVMs. It’s accurate when labels are reliable.  
Unsupervised learning finds unusual patterns (outliers) in code metrics or logs without labels. It’s useful when labeled data is unavailable. A hybrid approach can combine both for better bug detection.

### Q3: Why Bias Mitigation Matters in AI Personalization

Bias can lead to unfair recommendations or exclusion of users. For instance, AI that personalizes interfaces may favor certain demographics if data is unbalanced.  
Bias mitigation ensures fairness through balanced data, fairness testing tools, and transparent algorithms — building trust and inclusivity.

### Case Study: AIOps in DevOps

AIOps uses ML to automate deployment and monitoring.  
Examples:

1. Predictive scaling — automatically adjusts server resources before overloads occur.  
2. Smart rollbacks — detects anomalies after a deployment and reverts changes automatically.  
Result: fewer outages, faster recovery, and smoother deployments.
